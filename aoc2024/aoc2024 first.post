rec Int_Array {
    values: [int]
}

rec Graph {
    names: [str]
    vertex_names_to_index: #[str, int]
    edges: #[int, Int_Array]
}


fn ensure_vertex(g: Graph, vertex_name: str)
    if map_has_key(g.vertex_names_to_index, vertex_name) do ret map_get_value(g.vertex_names_to_index, vertex_name)
    index = len(g.names)
    push(g.names, vertex_name)
    map_add(g.vertex_names_to_index, vertex_name, index)
    ret index
end

fn add_vertex_edge(g: Graph, a: int, b: int)
    if map_has_key(g.edges, a) {
        to = map_get_value(g.edges, a)
        push(to.values, b)
    } else {
        to = Int_Array {}
        to.values = [int]
        push(to.values, b)
        map_add(g.edges, a, to)
    }
end

fn add_edge(g: Graph, s1: str, s2: str)
    a = ensure_vertex(g, s1)
    b = ensure_vertex(g, s2)
    add_vertex_edge(g, a, b)
    add_vertex_edge(g, b, a)
end

fn fill_isle(g: Graph, visited: [int], vertices: [int], vi: int)
    if visited[vi] > 0 do ret
    visited[vi] = 1
    push(vertices, vi)
    for map_get_value(g.edges, vi).values {
        fill_isle(g, visited, vertices, it)
    }
end

fn get_isles(g: Graph) 
    result = [str]
    visited = [int]
    arr_set_len(visited, len(g.names))
    for 0..len(g.names) - 1 {
        vertices = [int]
        fill_isle(g, visited, vertices, it)
        if len(vertices) > 0 {
            names = [str]
            for vertices do push(names, g.names[it])
            push(result, str_arr_join(names, ','))
        }
    }
    ret result
end

rec Three {
    a: int
    b: int
    c: int
}

fn get_threes(g: Graph) 
    result = [str]
    visited = #[Three, int]
    a = [int]
    t = Three {}
    for g.names {
        v1 = idx
        for map_get_value(g.edges, v1).values {
            v2 = it
            for map_get_value(g.edges, v2).values {
                v3 = it
                for map_get_value(g.edges, v3).values {
                    v4 = it
                    if v1 = v4 {
                        arr_set_len(a, 0)
                        push(a, v1)
                        push(a, v2)
                        push(a, v3)
                        arr_sort(a)
                        t.a = a[0]
                        t.b = a[1]
                        t.c = a[2]
                        if map_has_key(visited, t) = 0 {
                            map_add(visited, t, 0)
                            s = g.names[t.a] + ',' + g.names[t.b] + ',' + g.names[t.c]
                            push(result, s)
                        }
                    }
                }
            }
        }
    }
    ret result
end

fn run
    lines = read_string_lines_from_file('D:/src/postal/aoc2024/input.txt')
    g = Graph {}
    g.names = [str]
    g.vertex_names_to_index = #[str, int]
    g.edges = #[int, Int_Array]

    for lines {
        p = str_split(it, '-')
        add_edge(g, p[0], p[1])
    }

    // for g.names {
    //     log(it)
    //     a = map_get_value(g.edges, idx)
    //     for a.values {
    //         log('   ', g.names[it])
    //     }
    // }

    isles = get_threes(g)
    total = 0
    for isles {
        log(it)
        for str_split(it, ',') {
            if str_to_chars(it)[0] = 't' {
                total = total + 1
                break
            }
        }
    }
    
    log('done', total)
end
